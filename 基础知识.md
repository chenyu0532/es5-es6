1. ==会先转换数据类型再比较
   ===是类型和数值一起比较，都相同才为true，否则为false
   特殊:NaN与其他数值都不相同，唯一只有isNaN(NaN)才为true

2. 比较两个浮点数是否相等不能用===，应改用Math.abs(a - b) < 0.0000001(这是自己定义的)来比较

3. 多行字符串用` `来表示 
    `你是
    一只
    猪`
    则输出: 你是
    		一只
    		猪

4. 拼接字符串的方法
	(1) "11" + 22 + "333" 
	(2) `11, ${key1}, 我是${key2}`

5.  数组: indexOf(value) //获取这个value在数组里的位置
		 slice(begin, end) //截取begin到end的元素   如果是slice()则是复制这个数组
		 push("z", "a") 往末尾添加这些元素
		 pop() //删除最后一个元素
		 unshift("z", "a") //向头部添加这些元素
		 shift() //删除第一个元素
		 sort()//排序
		 reverse() //数组反转
		 splice(begin, end, "a", "b", "c")//删除begin到end的元素，添加后面的元素
		 数组1.concat(数组2)//连接两个数组
		 join("符号")//用符号把数组中国的元素连接起来

6. 对象: var xiaoming = {
						name:"xiaoming",
						'middle-school':"No1 school",
						score: 60
					}
		从上面可以看出 key有特殊字符时，用''
					  value可以使字符串、数字、函数 等等
		判断一个对象是否包含某属性用 xiaoming.hasOwnProperty('属性')

7. 循环:  for(初始值; 条件; 怎样变化) 或者 for(var key in 数组)
		  然而更推荐的是: for(var key of 数组)
		  最推荐的是: a.forEach(function(element, index, array){
		  					//element指向当前元素的值
		  					//index当前索引
		  					//array指向Array对象本身
		  				  })

8. Map: var map = new Map()  //极高的查找效率
		map.set(key, value)

	Set: var set = new Set()
		 set.add(key)

	Map和Key的作用相似，Set只是存储不同的key，没有value

9.  (1) function func(x){ ... }    调用的时候用func(1)
	(2) var func = function(x)		调用的时候用func(1)
		{
		};
	关键字arguments:只在函数内部起作用，永远指向当前函数的调用者传入的所有参数
	比如函数参数设定为2个，但是调用的时候传入了3个，则arguments指向的是这3个参数
	经常用来判断传入的参数个数 arguments.length

	rest参数:获取已定义参数之外的参数   function foo(a, b, ...rest)  
	当传入foo(1, 2, 3,4 ,5)的时候返回数组[3, 4, 5]

10. js有一个默认全局变量windows，任意类型的数值和函数等都可通过windows.xxx来调用

11. var 与 let的区别: ES6中尽量尽量用let来定义变量  const来定义常量
	
	解构赋值: let [x, y, z] = ["111", "222", "333"];
			 等价于 let x = "111"
			 		let y = "222"
			 		let z = "333"

12. 方法：在对象中定义函数
		var xiaoming = {
					name:xiaoxiao,
					birth:1990,
					age:function(){
						//todo
					}
				};
	或者 function getAge() {
			//todo
			//this.birth
		}

		var xiaoming = {
					name:"xiaoming",
					birth = 1990,
					age:getAge()
				};
		xiaoming.age(); //调用这个函数的结果

13. this关键字：只有像xiaoming.age() 这样的调用，getAge()函数里的this才指向xiaoming,其余形式的都是undefined
			或者xiaoming = {
						name:"xiaoming",
						birth = 1990,
						age:function(){
							function func2()
								//this.birth     
							end
						}
					}
			这样的话this也不指向xaioming,而是undefined,如果想用这种写法的话可以写成
				age:function()
				{
					let that = this
					function func2()
					{
						//that.birth
					}
				}

14. map(): 接受一个函数对象，该函数作用在数组Array中每一个元素上，并生成新的Array
		function pow(x)
		{
			return x * x;
		}
		var arr = [1, 2, 3,4]
		arr.map(pow); //1 4 9 16
		arr.map(String); // "1" "2" "3" "4"

	reduce():接受一个函数对象，这个函数对象必须要传两个参数。作用是吧结果继续和数组的下一个元素做累积计算
		function product(arr) //求数组的积
		{
			return arr.reduce(function(x, y)
					{
						return x * y;
					});
		}

	filter():把Array中的某些元素删掉，返回剩下的元素
	例如：let r = arr.filter(function(s){   //s表示数组的某个元素
				return s & s.trim()  //去掉空字符串
			})
	其实回调函数可以有多个参数
		var r = arr.filter(function(element, index, self){
				//element表示某个元素
				//index表示元素的位置0 1 2...
				//self表示数组本身,即arr
			})

	sort():排序，是把所有元素转换为String再进行排序，比较的是ASCII码
	如：[1,2,10,20].sort()  //1 10 2 20
	所以正确的做法是
		arr.sort(function(x, y){
			if(x < y)
			{
				return -1
			}
			if(x > y)
			{
				return 1
			}
		})  //有小到大
		arr.sort(function(x, y){
			if(x < y)  //有时候可以先对元素都转化为大写或小写再来比较
			{
				return 1
			}
			if(x > y)
			{
				return -1
			}
		})  //由大到小
		注：sort()是直接对原数组进行改变

15. 闭包