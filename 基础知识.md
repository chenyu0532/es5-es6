1. ==会先转换数据类型再比较
   ===是类型和数值一起比较，都相同才为true，否则为false
   特殊:NaN与其他数值都不相同，唯一只有isNaN(NaN)才为true

2. 比较两个浮点数是否相等不能用===，应改用Math.abs(a - b) < 0.0000001(这是自己定义的)来比较

3. 多行字符串用` `(单引号)来表示 
    `你是
    一只
    猪`
    则输出: 你是
    		一只
    		猪

4. 拼接字符串的方法
	(1) "11" + 22 + "333" 
	(2) let key1 = "你好";
		let key2 = "小明";
		console.log(`11, ${key1}, 我是${key2}`) 注意这里用的是单引号
5.  操作字符串的方法:toUpperCase  转为大写
					toLowerCase  转为小写
					indexOf("")  返回指定字符串的索引位置，没有找到则返回-1
					substring(begin, end) 返回这个区间的字符串

5.  数组: indexOf(value) //获取这个value在数组里的位置

		 slice(begin, end) //截取begin到end的元素,end可省略说明截取到最后

		 slice()则是复制这个数组

		 push("z", "a") 往末尾添加这些元素

		 pop() //删除最后一个元素

		 unshift("z", "a") //向头部添加这些元素

		 shift() //删除第一个元素

		 sort()//排序

		 reverse() //数组反转

		 splice(begin, n, "a", "b", "c")//删除从begin开始n个元素，并在删除的位置添加后面的元素
		 特殊用法:清空数组 splice(0, arr.length);

		 数组1.concat(数组2)//连接两个数组

		 join("符号")//用符号把数组中的元素连接起来

6. 对象: var xiaoming = {
						name:"xiaoming",

						'middle-school':"No1 school",

						score: 60}

		从上面可以看出 key有特殊字符时，用''单引号，访问有特殊字符的key时，用xiaoming[middle-school']访问
					  value可以使字符串、数字、函数 等等
		判断一个对象是否包含某属性用 xiaoming.hasOwnProperty('属性')

7. 循环:  for(初始值; 条件; 怎样变化)
		  for(var key in 数组)  --->输出的元素总是string类型，不推荐用
		  然而更推荐的是: for(var key of 数组)
		  最推荐的是: a.forEach(function(element, index, array){

		  					//element指向当前元素的值

		  					//index当前索引
		  					
		  					//array指向Array对象本身

		  				  })

8. Map: var map = new Map()  //极高的查找效率
		map.set(key, value)  //每个元素都是一个键值对，如果多次输入的key都一样，则后面会覆盖前面的

	Set: var set = new Set()
		 set.add(key)

	Map和Key的作用相似，Set只是存储不同的key,会自动删除重复的key,没有value

	遍历Map和Set时不能使用下标来循环

9.  (1) function func(x){ ... }    调用的时候用func(1)---creator里一般用这种方法，需要返回值的话直接return即可
	(2) var func = function(x)		调用的时候用func(1)
		{
		};
	(不是特别重要)关键字arguments:只在函数内部起作用，永远指向当前函数的调用者传入的所有参数
	比如函数参数设定为2个，但是调用的时候传入了3个，则arguments指向的是这3个参数
	经常用来判断传入的参数个数 arguments.length

	rest参数:获取已定义参数之外的参数   function foo(a, b, ...rest)  
	当传入foo(1, 2, 3,4 ,5)的时候返回Array[3, 4, 5]
	当传入foo(1)  ---> a = 1 b = undefined Array = []

10. js的函数可以嵌套,此时,内部函数可以访问在外部函数定义的变量，反过来则不行
	JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。

10. js有一个默认全局变量windows，任意类型的数值和函数等都可通过windows.xxx来调用

11. var 与 let的区别: ES6中尽量尽量用let来定义变量  const来定义常量const PI 3.14;
	
	解构赋值: let [x, y, z] = ["111", "222", "333"];
			 等价于 let x = "111"
			 		let y = "222"
			 		let z = "333"
			 也可以忽略某些元素，如：let [_, _, z] = ["111", "222", "333"]--->z = "333"
			 还可以有如下用法：
			 	let person = {
				    name: '小明',
				    age: 20,
				    gender: 'male',
				    passport: 'G-12345678',
				    school: 'No.4 middle school'
				    address:{
				    	city:'beijing'
				    	zipcode : '10000'
				    }
				};
				let {name, age, passport} = person;-->name = `小明` age = 20 passport = 'G-12345678'
				let {name, address: {city, zipcode}} = person;
				

12. 方法：在对象中定义函数
		var xiaoming = {
					name:xiaoxiao,
					birth:1990,
					age:function(){
						//todo
					}
				};
	或者 function getAge() {
			//todo
			//this.birth
		}

		var xiaoming = {
					name:"xiaoming",
					birth = 1990,
					age:getAge()
				};
		xiaoming.age(); //调用这个函数的结果

13. this关键字：只有像xiaoming.age() 这样的调用，getAge()函数里的this才指向xiaoming,其余形式的都是undefined
			或者xiaoming = {
						name:"xiaoming",
						birth = 1990,
						age:function(){
							function func2()
								//this.birth     
							end
						}
					}
			这样的话this也不指向xaioming,而是undefined,如果想用这种写法的话可以写成
				age:function()
				{
					let that = this
					function func2()
					{
						//that.birth
					}
				}

14. map(): 接受一个函数对象，该函数作用在数组Array中每一个元素上，并生成新的Array
		function pow(x)
		{
			return x * x;
		}
		var arr = [1, 2, 3,4]
		arr.map(pow); //1 4 9 16
		arr.map(String); // "1" "2" "3" "4"

	reduce():接受一个函数对象，这个函数对象必须要传两个参数。作用是吧结果继续和数组的下一个元素做累积计算
		function product(arr) //求数组的积
		{
			return arr.reduce(function(x, y)
					{
						return x * y;
					});
		}

	filter():把Array中的某些元素删掉，返回剩下的元素
	例如：let r = arr.filter(function(s){   //s表示数组的某个元素
				return s & s.trim()  //去掉空字符串
			})
	其实回调函数可以有多个参数
		var r = arr.filter(function(element, index, self){
				//element表示某个元素
				//index表示元素的位置0 1 2...
				//self表示数组本身,即arr
			})

	sort():排序，是把所有元素转换为String再进行排序，比较的是ASCII码
	如：[1,2,10,20].sort()  //1 10 2 20
	所以正确的做法是
		arr.sort(function(x, y){
			if(x < y)
			{
				return -1
			}
			if(x > y)
			{
				return 1
			}
		})  //有小到大
		arr.sort(function(x, y){
			if(x < y)  //有时候可以先对元素都转化为大写或小写再来比较
			{
				return 1
			}
			if(x > y)
			{
				return -1
			}
		})  //由大到小
		注：sort()是直接对原数组进行改变

15. 闭包: 就是能够读取其他函数内部变量的函数,换句话说也就是函数内部的函数
		function f1()
		{
			var n = 999;
			function f2()
			{
				console.log(n);
			}
			return f2;
		}
		var result = f1();
		result() --->999     f2函数就是闭包!

16. 