
1. 属性的简洁写法(属性 = 属性名+值)
	const foo = 'bar';
	const baz = {foo};
	console.log(baz)--->{foo:'bar'}
	或者
	function(x, y){
		return {x, y};   ---> return {x:x, y:y};
	}
	所以只要一个值是{zzzz}这种形式的，实际就是{zzzz:zzzz}

2. 属性名也可以用表达式 obj['a' + 'bc'] = 123;

3. ****可枚举性和遍历
	let obj = { foo: 123 };
	Object.getOwnPropertyDescriptor(obj, 'foo') //获取该属性的描述对象
	//  {
	//    value: 123,
	//    writable: true,
	//    enumerable: true,   
	//    configurable: true
	//  }
	enumerable是true的时候表示是可枚举的，如果该属性为false，就表示某些操作会忽略当前属性。
	for...in   Object.keys()   JSON.stringify()   Object.assign()  这些不受enumerable影响

4. 扩展运算符用在对象上与用在数组中是不同的,不过解构赋值依然要放在最后，是浅拷贝
	let {x, y, ...z} = {x:1, y:2, a:3, b:4}
	x  //1
	y  //2
	z  //{a:3, b:4}

	let z = { a: 3, b: 4 };
	let n = { ...z };
	n // { a: 3, b: 4 }

	let foo = { ...['a', 'b', 'c'] };
	foo
	// {0: "a", 1: "b", 2: "c"}

	{...'hello'}
	// {0: "h", 1: "e", 2: "l", 3: "l", 4: "o"}

5. Object.is(xxx,xxxx);  
	基本跟===作用相同，不过Object.is(+0, -0) // false
						 Object.is(NaN, NaN) // true

	Object.assign(target, source1, sourcen) //浅拷贝，将source合并到target里，有同名的属性则后面的
	会覆盖前面的


